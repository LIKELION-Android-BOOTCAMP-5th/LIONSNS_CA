#  프로젝트 아키텍처

**아키텍처 패턴**: MVVM + Feature-Based + Clean Architecture (완전 적용)

---

##  목차

1. [아키텍처 개요](#1-아키텍처-개요)
2. [레이어 구조](#2-레이어-구조)
3. [실제 프로젝트 구조](#3-실제-프로젝트-구조)
4. [Repository 패턴](#4-repository-패턴)
5. [Factory 패턴 (의존성 역전 강화)](#5-factory-패턴-의존성-역전-강화)
6. [예제 코드](#6-예제-코드)
7. [데이터 흐름](#7-데이터-흐름)
8. [Riverpod 상태 관리](#8-riverpod-상태-관리)
9. [위젯 아키텍처](#9-위젯-아키텍처)

---

## 1. 아키텍처 개요

### 1.1 아키텍처 패턴

이 프로젝트는 다음 패턴을 조합하여 사용합니다:

- **MVVM (Model-View-ViewModel)**: 상태 관리와 UI 분리
- **Feature-Based Structure**: 기능별 모듈 분리
- **Clean Architecture**: 레이어 분리 (Domain, Data, Presentation)
- **Use Case Pattern**: 비즈니스 로직 캡슐화
- **Repository Pattern**: 데이터 소스 추상화
- **DTO Pattern**: 데이터 전송 객체 분리
- **Dependency Injection**: Riverpod을 통한 DI

### 1.2 핵심 원칙

1. **Feature 기반 분리**: 각 feature는 독립적인 모듈
2. **레이어 분리**: Domain, Data, Presentation 명확히 분리
3. **의존성 방향**: Presentation → Domain ← Data (의존성 역전 원칙)
4. **Use Case 패턴**: 비즈니스 로직을 Use Case로 캡슐화
5. **Repository 추상화**: 인터페이스와 구현체 분리
6. **DTO 분리**: Domain Entity와 Data DTO 분리
7. **확장 가능**: 백엔드 교체 시 Repository 구현만 변경

---

## 2. 레이어 구조

### 2.1 전체 흐름

```
View → ViewModel → Use Case → Repository → Datasource → Service
```

**Clean Architecture 데이터 흐름**:
- **Presentation Layer**: View → ViewModel → Use Case
- **Domain Layer**: Use Case → Repository (인터페이스)
- **Data Layer**: Repository (구현체) → Datasource → DTO → Entity 변환

### 2.2 각 레이어의 역할

#### 1. View (Presentation Layer)
**위치**: `lib/features/*/presentation/pages/`

**역할**:
- UI 렌더링
- 사용자 입력 처리
- ViewModel과 상호작용

**특징**:
- `ConsumerWidget` 또는 `ConsumerStatefulWidget` 사용
- Riverpod Provider를 통해 ViewModel 접근
- 비즈니스 로직 포함하지 않음

**예시**:
```dart
class ProfileScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final authResult = ref.watch(authViewModelProvider);
    
    return authResult.when(
      success: (user) => _buildProfile(user),
      failure: (message, _) => _buildError(message),
      pending: (_) => _buildLoading(),
    );
  }
}
```

---

#### 2. ViewModel (Presentation Layer)
**위치**: `lib/features/*/presentation/viewmodels/`

**역할**:
- 상태 관리 (StateNotifier)
- Use Case를 통한 비즈니스 로직 실행
- UI 상태 관리

**특징**:
- `StateNotifier` 또는 `StateNotifierProvider` 사용
- **Use Case에만 의존** (Repository 직접 접근 불가)
- **Datasource 직접 접근 불가**
- UI와 독립적 (테스트 용이)

**Clean Architecture 원칙 준수**:
-  모든 ViewModel이 UseCase만 사용
-  Repository 직접 사용 완전 제거
-  Datasource 직접 사용 완전 제거

**예시**:
```dart
class AuthViewModel extends StateNotifier<Result<User?>> {
  final SignInUseCase _signInUseCase;
  final GetCurrentUserUseCase _getCurrentUserUseCase;
  
  AuthViewModel({
    required SignInUseCase signInUseCase,
    required GetCurrentUserUseCase getCurrentUserUseCase,
  })  : _signInUseCase = signInUseCase,
        _getCurrentUserUseCase = getCurrentUserUseCase,
        super(Success<User?>(null));
  
  Future<void> signIn(AuthProvider provider) async {
    state = Pending<User?>('로그인 중...');
    final result = await _signInUseCase(provider);
    state = result;
  }
}
```

---

#### 3. Use Case (Domain Layer)
**위치**: `lib/features/*/domain/usecases/`

**역할**:
- 비즈니스 로직 캡슐화
- 단일 책임 원칙 (하나의 Use Case는 하나의 작업)
- Repository 인터페이스에 의존

**특징**:
- Domain Layer에 위치 (외부 의존성 없음)
- Repository 인터페이스만 의존
- 테스트 용이 (Mock Repository 주입 가능)

**예시**:
```dart
class SignInUseCase {
  final AuthRepository _authRepository;
  
  SignInUseCase(this._authRepository);
  
  Future<Result<User?>> call(AuthProvider provider) {
    return _authRepository.snsLogin(provider);
  }
}
```

#### 4. Repository (Domain Layer - 인터페이스)
**위치**: `lib/features/*/domain/repositories/`

**역할**:
- 추상화 레이어 (인터페이스 정의)
- 백엔드 독립적인 도메인 로직 정의
- Use Case가 의존하는 계약(Contract) 정의

**특징**:
- Domain Layer에 위치
- 구체적인 구현 없음 (추상 클래스)
- 백엔드 교체 시 인터페이스는 유지

**예시**:
```dart
abstract class AuthRepository {
  Future<Result<User?>> snsLogin(AuthProvider provider);
  Future<Result<User?>> getCurrentUser();
  Future<Result<void>> logout();
}
```

---

#### 5. Repository 구현체 (Data Layer)
**위치**: `lib/features/*/data/repositories/`

**역할**:
- Repository 인터페이스의 구체적 구현
- Datasource를 사용하여 실제 데이터 처리
- DTO를 Entity로 변환
- **백엔드 교체 시 이 부분만 변경**

**예시**:
```dart
class SupabaseAuthRepository implements AuthRepository {
  final AuthDatasource _authDatasource;
  
  SupabaseAuthRepository(this._authDatasource);
  
  @override
  Future<Result<User?>> snsLogin(AuthProvider provider) {
    return _authDatasource.snsLogin(provider);
  }
}
```

#### 6. DTO (Data Transfer Object) - Data Layer
**위치**: `lib/features/*/data/dtos/`

**역할**:
- 외부 데이터 소스와 통신용 객체
- JSON 직렬화 포함
- Entity와 DTO 간 변환 메서드 제공

**특징**:
- Data Layer에 위치
- JSON 직렬화 포함 (`@JsonSerializable`)
- Domain Entity와 분리

**예시**:
```dart
@JsonSerializable()
class UserDto {
  final String id;
  final String name;
  final String email;
  @JsonKey(name: 'profile_image_url')
  final String? profileImageUrl;
  final String provider;
  @JsonKey(name: 'created_at')
  final String createdAt;
  
  // JSON 직렬화
  factory UserDto.fromJson(Map<String, dynamic> json) => _$UserDtoFromJson(json);
  Map<String, dynamic> toJson() => _$UserDtoToJson(this);
  
  // Entity 변환
  User toEntity() {
    return User(
      id: id,
      name: name,
      email: email,
      profileImageUrl: profileImageUrl,
      provider: _parseProvider(provider),
      createdAt: DateTime.parse(createdAt),
    );
  }
}
```

---

#### 7. Datasource (Data Layer)
**위치**: `lib/features/*/data/` 또는 `lib/features/*/data/datasources/`

**역할**:
- 특정 백엔드(Supabase/Firebase)의 구체적 구현
- Service를 사용하여 실제 API 호출
- DTO를 사용하여 데이터 처리
- `Result<T>` 타입 반환 (Domain Entity)

**특징**:
- DTO를 사용하여 외부 데이터 처리
- DTO → Entity 변환 수행
- Service 레이어에 의존

**예시**:
```dart
class AuthDatasource {
  Future<Result<User?>> snsLogin(AuthProvider provider) async {
    try {
      final response = await SupabaseService.client.auth.signInWithOAuth(...);
      // DTO로 변환 후 Entity로 변환
      final userDto = UserDto.fromJson(response);
      final user = userDto.toEntity();
      return Success<User?>(user);
    } catch (e) {
      return Failure<User?>('로그인 실패: $e');
    }
  }
}
```

---

#### 8. Entity (Domain Layer)
**위치**: `lib/features/*/domain/`

**역할**:
- 순수한 비즈니스 객체
- 외부 의존성 없음 (JSON 직렬화 제거)
- 비즈니스 로직 포함 가능

**특징**:
- Domain Layer에 위치
- 외부 라이브러리 의존성 없음
- 순수한 Dart 클래스

**예시**:
```dart
/// User Entity - Domain Layer
/// 순수한 비즈니스 객체로, 외부 의존성 없음
class User {
  final String id;
  final String name;
  final String email;
  final String? profileImageUrl;
  final AuthProvider provider;
  final DateTime createdAt;
  
  const User({...});
  
  User copyWith({...}) {
    // ...
  }
}
```

#### 9. Service (Core Layer)
**위치**: `lib/core/services/`

**역할**:
- 외부 SDK 래퍼 (Supabase, Firebase 등)
- 초기화 및 설정 관리
- SDK별 특화 로직

**구조**:
```
core/services/
├── external/              # 외부 서비스
│   ├── supabase_service.dart
│   └── firebase_service.dart
└── internal/              # 내부 서비스
    ├── auth_provider_service.dart
    ├── storage_service_interface.dart
    └── supabase_storage_service.dart
```

---

### 2.3 레이어별 의존성 규칙 (Clean Architecture)

```
 View → ViewModel (의존 가능)
 ViewModel → Use Case (의존 가능)
 Use Case → Repository 인터페이스 (의존 가능)
 Repository 구현체 → Datasource (의존 가능)
 Datasource → DTO → Entity 변환
 Datasource → Service (의존 가능)

 View → Use Case (의존 불가)
 View → Datasource (의존 불가)
 ViewModel → Repository 직접 (의존 불가) - **완전 제거됨**
 ViewModel → Datasource (의존 불가) - **완전 제거됨**
 ViewModel → Service 구현체 직접 (의존 불가)
 Use Case → Repository 구현체 (의존 불가)
 Use Case → Datasource (의존 불가)
 Domain → Data (의존 불가)
 Domain → Presentation (의존 불가)
```

**현재 프로젝트 상태**:
-  모든 ViewModel이 UseCase만 사용
-  모든 feature에서 Factory 패턴 적용 (search, auth, feed)
-  Presentation 레이어가 Domain 레이어만 import
-  Repository/Datasource 직접 사용 완전 제거
-  LikedPostsViewModel도 UseCase 사용 (완전 적용)

**의존성 방향**:
```
Presentation Layer
    ↓ (의존)
Domain Layer (Use Cases, Repository 인터페이스, Entities)
    ↑ (구현)
Data Layer (Repository 구현체, DTOs, Datasources)
    ↓ (의존)
Core Layer (Services)
```

---

## 3. 실제 프로젝트 구조

### 3.1 전체 구조

```
lib/
├── main.dart                    # 앱 진입점
├── config/                      # 앱 설정
│   └── router.dart              # GoRouter 라우팅 설정
│
├── core/                        # 공통 모듈
│   ├── services/                # 서비스 레이어
│   │   ├── external/            # 외부 서비스 (Supabase, Firebase)
│   │   └── internal/            # 내부 서비스 (Storage, Auth Provider)
│   ├── utils/                   # 유틸리티
│   │   └── result.dart          # Result 패턴
│   └── widgets/                 # 공통 위젯
│
└── features/                    # 기능별 모듈 (Feature-Based)
    ├── auth/                    # 인증 기능
    │   ├── domain/              # Domain Layer
    │   │   ├── user.dart        # User Entity (순수 객체)
    │   │   ├── usecases/        # Use Cases
    │   │   │   ├── sign_in_usecase.dart
    │   │   │   ├── get_current_user_usecase.dart
    │   │   │   ├── logout_usecase.dart
    │   │   │   └── ...
    │   │   └── repositories/    # Repository 인터페이스
    │   │       ├── auth_repository.dart
    │   │       ├── profile_repository.dart
    │   │       └── follow_repository.dart
    │   ├── data/                # Data Layer
    │   │   ├── dtos/            # DTOs (JSON 직렬화 포함)
    │   │   │   └── user_dto.dart
    │   │   ├── datasources/     # Data Sources
    │   │   │   ├── supabase_auth_datasource.dart
    │   │   │   ├── supabase_profile_datasource.dart
    │   │   │   └── supabase_follow_datasource.dart
    │   │   └── repositories/    # Repository 구현체
    │   │       ├── supabase_auth_repository.dart
    │   │       ├── supabase_profile_repository.dart
    │   │       └── supabase_follow_repository.dart
    │   └── presentation/        # Presentation Layer
    │       ├── providers/       # Provider 정의
    │       ├── viewmodels/      # ViewModel (Use Cases 사용)
    │       ├── pages/           # 화면
    │       └── widgets/         # Feature 전용 위젯
    │
    └── feed/                    # 피드 기능
        ├── domain/              # Domain Layer
        │   ├── post.dart        # Post Entity (순수 객체)
        │   ├── comment.dart     # Comment Entity (순수 객체)
        │   ├── usecases/        # Use Cases
        │   │   ├── get_posts_usecase.dart
        │   │   ├── create_post_usecase.dart
        │   │   ├── get_comments_usecase.dart
        │   │   └── ...
        │   └── repositories/    # Repository 인터페이스
        │       ├── post_repository.dart
        │       ├── comment_repository.dart
        │       └── like_repository.dart
        ├── data/                # Data Layer
        │   ├── dtos/            # DTOs
        │   │   ├── post_dto.dart
        │   │   └── comment_dto.dart
        │   ├── datasources/     # Data Sources
        │   │   ├── post_datasource.dart
        │   │   ├── comment_datasource.dart
        │   │   └── like_datasource.dart
        │   └── repositories/    # Repository 구현체
        │       ├── supabase_post_repository.dart
        │       ├── supabase_comment_repository.dart
        │       └── supabase_like_repository.dart
        └── presentation/        # Presentation Layer
            ├── providers/       # Provider 정의
            │   ├── providers.dart       # 통합 export
            │   ├── usecase_providers.dart   # UseCase Provider
            │   └── viewmodel_providers.dart # ViewModel Provider
            ├── viewmodels/      # ViewModel (Use Cases 사용)
            ├── pages/           # 화면
            └── widgets/         # Feature 전용 위젯
```

---

### 3.2 Feature 표준 구조

각 Feature는 다음 구조를 따릅니다:

```
features/{feature_name}/
├── domain/                      # Domain Layer
│   ├── {entity}.dart           # Entity (순수 객체, JSON 직렬화 없음)
│   ├── usecases/               # Use Cases
│   │   ├── get_{entity}_usecase.dart
│   │   ├── create_{entity}_usecase.dart
│   │   └── ...
│   └── repositories/           # Repository 인터페이스
│       └── {feature}_repository.dart
│
├── data/                        # Data Layer
│   ├── dtos/                    # DTOs (JSON 직렬화 포함)
│   │   └── {entity}_dto.dart
│   ├── datasources/             # Data Sources
│   │   └── {feature}_datasource.dart
│   └── repositories/            # Repository 구현체
│       └── supabase_{feature}_repository.dart
│
└── presentation/                # Presentation Layer
    ├── providers/               # Provider 정의
    │   ├── providers.dart       # 통합 export (사용 편의성)
    │   ├── usecase_providers.dart   # UseCase Provider
    │   └── viewmodel_providers.dart # ViewModel Provider
    ├── viewmodels/              # ViewModel (Use Cases 사용)
    │   └── {feature}_{action}_viewmodel.dart
    ├── pages/                   # 화면
    │   └── {feature}_{action}_screen.dart
    └── widgets/                 # Feature 전용 위젯
        └── {widget}.dart
```

---

### 3.3 현재 프로젝트의 실제 구조

#### Auth Feature
```
features/auth/
├── domain/                      # Domain Layer
│   ├── user.dart                # User Entity (순수 객체)
│   ├── usecases/                # Use Cases
│   │   ├── sign_in_usecase.dart
│   │   ├── get_current_user_usecase.dart
│   │   ├── logout_usecase.dart
│   │   ├── watch_auth_state_usecase.dart
│   │   ├── get_profile_usecase.dart
│   │   ├── update_profile_usecase.dart
│   │   ├── toggle_follow_usecase.dart
│   │   ├── get_follow_status_usecase.dart
│   │   └── get_follow_list_usecase.dart
│   └── repositories/           # Repository 인터페이스
│       ├── auth_repository.dart
│       ├── profile_repository.dart
│       └── follow_repository.dart
│
├── data/                        # Data Layer
│   ├── datasources/             # Data Sources
│   │   ├── supabase_auth_datasource.dart
│   │   ├── supabase_profile_datasource.dart
│   │   └── supabase_follow_datasource.dart
│   ├── datasource_providers.dart # Datasource Provider
│   ├── dtos/                    # DTOs
│   │   └── user_dto.dart        # JSON 직렬화 포함
│   ├── factories/               # Factory 구현체
│   │   └── supabase_repository_factory.dart
│   ├── providers/               # Factory Provider
│   │   └── factory_providers.dart
│   └── repositories/            # Repository 구현체
│       ├── supabase_auth_repository.dart
│       ├── supabase_profile_repository.dart
│       └── supabase_follow_repository.dart
│
└── presentation/                # Presentation Layer
    ├── providers/               # Provider 정의
    │   ├── providers.dart       # 통합 export (Domain Provider만 export)
    │   └── viewmodel_providers.dart # ViewModel Provider
    ├── viewmodels/
    │   ├── auth_viewmodel.dart          # Use Cases 사용
    │   ├── profile_edit_viewmodel.dart  # Use Cases 사용
    │   └── follow_viewmodel.dart        # Use Cases 사용
    ├── pages/
    │   ├── auth_screen.dart
    │   ├── profile_screen.dart
    │   └── profile_edit_screen.dart
    └── widgets/
        └── user_profile_options_sheet.dart
```

#### Feed Feature
```
features/feed/
├── domain/                      # Domain Layer
│   ├── entities/                # 엔티티
│   │   ├── post.dart            # Post Entity (순수 객체)
│   │   └── comment.dart         # Comment Entity (순수 객체)
│   ├── factories/               # Factory 인터페이스
│   │   └── repository_factory.dart
│   ├── providers/               # Provider (Domain 레이어)
│   │   ├── providers.dart       # 통합 export
│   │   ├── repository_providers.dart  # Factory Provider re-export
│   │   └── usecase_providers.dart     # UseCase Provider
│   ├── repositories/           # Repository 인터페이스
│   │   ├── post_repository.dart
│   │   ├── comment_repository.dart
│   │   └── like_repository.dart
│   └── usecases/                # Use Cases
│       ├── get_posts_usecase.dart
│       ├── get_post_by_id_usecase.dart
│       ├── create_post_usecase.dart
│       ├── update_post_usecase.dart
│       ├── delete_post_usecase.dart
│       ├── get_comments_usecase.dart
│       ├── create_comment_usecase.dart
│       ├── delete_comment_usecase.dart
│       ├── toggle_like_usecase.dart
│       ├── get_like_count_usecase.dart
│       └── get_user_liked_posts_usecase.dart
│
├── data/                        # Data Layer
│   ├── datasources/             # Data Sources
│   │   ├── supabase_post_datasource.dart
│   │   ├── supabase_comment_datasource.dart
│   │   └── supabase_like_datasource.dart
│   ├── datasource_providers.dart # Datasource Provider
│   ├── dtos/                    # DTOs
│   │   ├── post_dto.dart        # JSON 직렬화 포함
│   │   └── comment_dto.dart     # JSON 직렬화 포함
│   ├── factories/               # Factory 구현체
│   │   └── supabase_repository_factory.dart
│   ├── providers/               # Factory Provider
│   │   └── factory_providers.dart
│   └── repositories/           # Repository 구현체
│       ├── supabase_post_repository.dart
│       ├── supabase_comment_repository.dart
│       └── supabase_like_repository.dart
│
└── presentation/                # Presentation Layer
    ├── providers/               # Provider 정의
    │   ├── providers.dart       # 통합 export (Domain Provider만 export)
    │   └── viewmodel_providers.dart # ViewModel Provider
    ├── viewmodels/
    │   ├── post_list_viewmodel.dart      # Use Cases 사용
    │   ├── post_detail_viewmodel.dart    # Use Cases 사용
    │   ├── post_form_viewmodel.dart      # Use Cases 사용
    │   └── liked_posts_viewmodel.dart    # Use Cases 사용
    ├── pages/
    │   ├── post_list_screen.dart
    │   ├── post_detail_screen.dart
    │   └── post_form_screen.dart
    └── widgets/
        └── post_card.dart
```

---

### 3.4 구조 선택 가이드

#### 단순한 경우 (대부분의 Feature)
```
features/{feature}/
├── data/
│   └── {feature}_datasource.dart  # DataSource 직접 사용
├── domain/
│   └── {model}.dart               # 모델만
└── presentation/
    ├── viewmodels/                # DataSource 직접 호출
    └── pages/
```

**특징**:
- Repository 없이 DataSource 직접 사용
- 빠른 개발
- 간단한 구조

#### 복잡한 경우 (여러 데이터 소스)
```
features/{feature}/
├── data/
│   ├── datasources/              # 여러 DataSource
│   └── repositories/             # Repository 구현
├── domain/
│   ├── models/
│   └── repositories/             # Repository 인터페이스
└── presentation/
    ├── viewmodels/               # UseCase 사용
    └── pages/
```

**특징**:
- Repository 패턴으로 추상화
- 백엔드 교체 용이
- 확장 가능한 구조

---

## 4. Repository 패턴

### 4.1 Repository 패턴이란?

Repository 패턴은 데이터 소스에 대한 추상화 계층을 제공하여, 백엔드 독립적인 코드를 작성할 수 있게 합니다.

### 4.2 구조

```
ViewModel → UseCase → Repository 인터페이스 (Domain)
            ↓
        Repository 구현체 (Data) → Datasource → Service
```

### 4.3 장점

1. **의존성 역전**: ViewModel이 구체적인 구현이 아닌 추상화에 의존
2. **테스트 용이성**: Mock Repository를 쉽게 만들 수 있음
3. **유연성**: 백엔드 교체 시 Repository 구현만 변경
4. **확장성**: 여러 백엔드를 동시에 지원 가능

### 4.4 언제 사용할까?

####  Repository 패턴 사용 권장
- 여러 데이터 소스 조합 (API + 로컬 DB + 캐시)
- 백엔드 교체 가능성
- 복잡한 데이터 변환 필요
- 여러 DataSource를 하나로 통합할 때

####  Repository 패턴 불필요
- 단일 데이터 소스만 사용
- 간단한 CRUD 작업
- 프로젝트 규모가 작을 때

### 4.5 현재 프로젝트의 Repository 패턴

현재 프로젝트는 **Repository 패턴을 사용**하고 있습니다:

**Domain Layer** (인터페이스):
```dart
// features/auth/domain/repositories/auth_repository.dart
abstract class AuthRepository {
  Future<Result<User?>> snsLogin(AuthProvider provider);
  Future<Result<User?>> getCurrentUser();
  Future<Result<void>> logout();
}
```

**Data Layer** (구현):
```dart
// features/auth/data/repositories/supabase_auth_repository.dart
class SupabaseAuthRepository implements AuthRepository {
  final AuthDatasource _authDatasource;
  
  SupabaseAuthRepository(this._authDatasource);
  
  @override
  Future<Result<User?>> snsLogin(AuthProvider provider) {
    return _authDatasource.snsLogin(provider);
  }
}
```

**ViewModel** (UseCase 사용):
```dart
class AuthViewModel extends StateNotifier<Result<User?>> {
  final SignInUseCase _signInUseCase;
  final GetCurrentUserUseCase _getCurrentUserUseCase;
  
  AuthViewModel({
    required SignInUseCase signInUseCase,
    required GetCurrentUserUseCase getCurrentUserUseCase,
  })  : _signInUseCase = signInUseCase,
        _getCurrentUserUseCase = getCurrentUserUseCase,
        super(Success<User?>(null));
  
  Future<void> signIn(AuthProvider provider) async {
    state = Pending<User?>('로그인 중...');
    final result = await _signInUseCase(provider);
    state = result;
  }
}
```

**UseCase Provider** (의존성 주입):
```dart
final signInUseCaseProvider = Provider<SignInUseCase>((ref) {
  final factory = ref.watch(repositoryFactoryProvider);
  final repository = factory.createAuthRepository();
  return SignInUseCase(repository);
});

final getCurrentUserUseCaseProvider = Provider<GetCurrentUserUseCase>((ref) {
  final factory = ref.watch(repositoryFactoryProvider);
  final repository = factory.createAuthRepository();
  return GetCurrentUserUseCase(repository);
});
```

**ViewModel Provider** (UseCase 주입):
```dart
final authViewModelProvider = StateNotifierProvider<AuthViewModel, Result<User?>>((ref) {
  final signInUseCase = ref.watch(signInUseCaseProvider);
  final getCurrentUserUseCase = ref.watch(getCurrentUserUseCaseProvider);
  return AuthViewModel(
    signInUseCase: signInUseCase,
    getCurrentUserUseCase: getCurrentUserUseCase,
  );
});
```

---

## 5. Factory 패턴 (의존성 역전 강화)

### 5.1 Factory 패턴이란?

Factory 패턴은 객체 생성 로직을 추상화하여, Domain 레이어가 Data 레이어의 구체적 구현을 직접 import하지 않도록 합니다. 이를 통해 **완벽한 의존성 역전 원칙(DIP) 준수**를 달성합니다.

### 5.2 구조

일반적인 Provider 패턴:
```
Domain Layer
    ↓ (import)
Data Layer (Repository Provider)
```

Factory 패턴:
```
Domain Layer (Factory 인터페이스)
    ↑ (구현)
Data Layer (Factory 구현체)
```

### 5.3 장점

1. **완벽한 DIP 준수**: Domain 레이어가 Data 레이어를 전혀 import하지 않음
2. **컴파일 타임 의존성 제거**: Domain 레이어는 Factory 인터페이스만 알고 있음
3. **유연한 교체**: Factory 구현체만 교체하면 백엔드 변경 가능
4. **테스트 용이성**: Mock Factory를 쉽게 주입 가능

### 5.4 언제 사용할까?

####  Factory 패턴 사용 권장
- **완벽한 의존성 역전이 필요한 경우**
- Domain 레이어가 Data 레이어를 전혀 import하지 않아야 할 때
- 프로젝트 규모가 크고 레이어 간 의존성을 엄격히 관리해야 할 때

####  일반 Provider 패턴 사용
- 대부분의 일반적인 경우 (현재 프로젝트의 auth, feed feature)
- Domain 레이어에서 Provider를 import하는 것이 허용되는 경우

### 5.5 현재 프로젝트의 Factory 패턴 적용

현재 프로젝트는 **모든 feature(auth, feed, search)에 Factory 패턴을 적용**하고 있습니다:

#### Domain Layer - Factory 인터페이스

**`features/search/domain/factories/repository_factory.dart`**:
```dart
/// Repository Factory 인터페이스
/// 
/// Domain 레이어에서 정의하는 Factory 인터페이스입니다.
/// Data 레이어에서 이 인터페이스를 구현하여 Repository를 생성합니다.
abstract class RepositoryFactory {
  SearchRepository createSearchRepository();
}
```

#### Domain Layer - Use Case

**`features/search/domain/usecases/search_usecase.dart`**:
```dart
/// 검색 Use Case
/// 
/// Factory 패턴을 사용하여 Repository를 생성합니다.
/// Domain 레이어는 Factory 인터페이스에만 의존하므로 Data 레이어를 직접 import하지 않습니다.
class SearchUseCase {
  final RepositoryFactory _factory;

  SearchUseCase(this._factory);

  Future<Result<SearchResults>> call(String query) {
    // Factory를 통해 Repository 생성 (구체적 구현 모름)
    final searchRepository = _factory.createSearchRepository();
    return searchRepository.search(query);
  }
}
```

#### Domain Layer - Provider (re-export)

**`features/search/domain/providers/repository_providers.dart`**:
```dart
/// Factory Provider Export (Domain 레이어)
/// 
/// Domain 레이어에서 Factory Provider를 re-export합니다.
/// Factory 패턴을 사용하여 Domain 레이어가 Data 레이어를 직접 import하지 않습니다.
export '../../data/providers/factory_providers.dart';
```

**`features/search/domain/providers/usecase_providers.dart`**:
```dart
final searchUseCaseProvider = Provider<SearchUseCase>((ref) {
  final factory = ref.watch(repositoryFactoryProvider); // Factory Provider
  return SearchUseCase(factory);
});
```

#### Data Layer - Factory 구현체

**`features/search/data/factories/supabase_repository_factory.dart`**:
```dart
/// Supabase Repository Factory 구현
/// 
/// Data 레이어에서 Domain 레이어의 Factory 인터페이스를 구현합니다.
class SupabaseRepositoryFactory implements RepositoryFactory {
  final SupabaseSearchDatasource _datasource;

  SupabaseRepositoryFactory(this._datasource);

  @override
  SearchRepository createSearchRepository() {
    return SupabaseSearchRepository(_datasource);
  }
}
```

**`features/search/data/providers/factory_providers.dart`**:
```dart
/// Repository Factory Provider (Data 레이어)
/// 
/// Data 레이어에서 Factory 구현체를 제공합니다.
final repositoryFactoryProvider = Provider<RepositoryFactory>((ref) {
  final datasource = ref.watch(searchDatasourceProvider);
  return SupabaseRepositoryFactory(datasource);
});
```

### 5.6 Factory 패턴 특징

현재 프로젝트의 모든 feature(auth, feed, search)는 **Factory 패턴을 사용**합니다:

```
Domain Layer (Use Case)
    ↓ import
Domain Layer (Factory 인터페이스) ← 추상화
    ↑ (구현)
Data Layer (Factory 구현체) ← Data가 Domain 인터페이스 구현
```

**특징**:
- Domain 레이어가 Data 레이어를 전혀 import하지 않음
- 컴파일 타임 의존성: 없음 (런타임 의존성만 존재)
- 완벽한 DIP 준수

### 5.7 Factory 패턴 데이터 흐름 (Search Feature)

```
1. View (SearchScreen)
   └─> searchViewModel.search(query) 호출

2. ViewModel (SearchViewModel)
   └─> _searchUseCase(query) 호출

3. Use Case (SearchUseCase)
   └─> _factory.createSearchRepository() 호출 (Factory 인터페이스만 알고 있음)
       └─> searchRepository.search(query) 호출

4. Factory 구현체 (SupabaseRepositoryFactory)
   └─> SupabaseSearchRepository 생성 (구체적 구현)
       └─> datasource.search(query) 호출

5. Repository 구현체 (SupabaseSearchRepository)
   └─> datasource.search(query) 호출

6. Datasource (SupabaseSearchDatasource)
   └─> Supabase 쿼리 실행
       └─> 결과 반환

7. 역순으로 결과 전달
   Datasource → Repository → Factory → Use Case → ViewModel → View
```

### 5.8 Factory 패턴 적용 Feature 구조

#### Auth Feature 구조

```
features/auth/
├── domain/                      # Domain Layer
│   ├── entities/
│   │   └── user.dart
│   ├── factories/               # Factory 인터페이스
│   │   └── repository_factory.dart  # 3개 Repository 생성 메서드
│   ├── repositories/
│   │   ├── auth_repository.dart
│   │   ├── profile_repository.dart
│   │   └── follow_repository.dart
│   ├── providers/
│   │   ├── repository_providers.dart  # Factory Provider re-export
│   │   └── usecase_providers.dart     # Factory 사용하여 Repository 생성
│   └── usecases/
│       ├── sign_in_usecase.dart
│       ├── get_current_user_usecase.dart
│       └── ...
│
├── data/                        # Data Layer
│   ├── datasources/
│   │   ├── supabase_auth_datasource.dart
│   │   ├── supabase_profile_datasource.dart
│   │   └── supabase_follow_datasource.dart
│   ├── factories/               # Factory 구현체
│   │   └── supabase_repository_factory.dart  # 3개 Repository 생성 구현
│   ├── providers/
│   │   └── factory_providers.dart  # Factory Provider 구현
│   └── repositories/
│       ├── supabase_auth_repository.dart
│       ├── supabase_profile_repository.dart
│       └── supabase_follow_repository.dart
│
└── presentation/                # Presentation Layer
    ├── providers/
    │   └── providers.dart
    ├── viewmodels/
    │   ├── auth_viewmodel.dart
    │   └── ...
    └── ...
```

#### Feed Feature 구조

```
features/feed/
├── domain/                      # Domain Layer
│   ├── entities/
│   │   ├── post.dart
│   │   └── comment.dart
│   ├── factories/               # Factory 인터페이스
│   │   └── repository_factory.dart  # 3개 Repository 생성 메서드
│   ├── repositories/
│   │   ├── post_repository.dart
│   │   ├── comment_repository.dart
│   │   └── like_repository.dart
│   ├── providers/
│   │   ├── repository_providers.dart  # Factory Provider re-export
│   │   └── usecase_providers.dart     # Factory 사용하여 Repository 생성
│   └── usecases/
│       ├── get_posts_usecase.dart
│       ├── create_post_usecase.dart
│       └── ...
│
├── data/                        # Data Layer
│   ├── datasources/
│   │   ├── supabase_post_datasource.dart
│   │   ├── supabase_comment_datasource.dart
│   │   └── supabase_like_datasource.dart
│   ├── factories/               # Factory 구현체
│   │   └── supabase_repository_factory.dart  # 3개 Repository 생성 구현
│   ├── providers/
│   │   └── factory_providers.dart  # Factory Provider 구현
│   └── repositories/
│       ├── supabase_post_repository.dart
│       ├── supabase_comment_repository.dart
│       └── supabase_like_repository.dart
│
└── presentation/                # Presentation Layer
    ├── providers/
    │   └── providers.dart
    ├── viewmodels/
    │   ├── post_list_viewmodel.dart
    │   └── ...
    └── ...
```

#### Search Feature 구조

```
features/search/
├── domain/                      # Domain Layer
│   ├── entities/
│   │   └── search_results.dart
│   ├── factories/               # Factory 인터페이스
│   │   └── repository_factory.dart  # 1개 Repository 생성 메서드
│   ├── repositories/
│   │   └── search_repository.dart
│   ├── providers/
│   │   ├── repository_providers.dart  # Factory Provider re-export
│   │   └── usecase_providers.dart     # Factory 사용
│   └── usecases/
│       └── search_usecase.dart  # Factory를 통해 Repository 생성
│
├── data/                        # Data Layer
│   ├── datasources/
│   │   └── supabase_search_datasource.dart
│   ├── factories/               # Factory 구현체
│   │   └── supabase_repository_factory.dart
│   ├── providers/
│   │   └── factory_providers.dart  # Factory Provider 구현
│   └── repositories/
│       └── supabase_search_repository.dart
│
└── presentation/                # Presentation Layer
    ├── providers/
    │   └── providers.dart
    ├── viewmodels/
    │   └── search_viewmodel.dart
    └── widgets/
        ├── comment_search_item.dart
        └── user_search_item.dart
```

### 5.9 Factory 패턴 적용 특징

- **모든 feature에 일관된 패턴**: auth, feed, search 모두 Factory 패턴 사용
- **다중 Repository 지원**: auth와 feed는 여러 Repository를 생성하는 Factory 메서드 제공
- **완벽한 DIP 준수**: Domain 레이어가 Data 레이어를 전혀 import하지 않음
- **유연한 확장성**: Factory 구현체만 교체하면 백엔드 변경 가능

---

## 6. 예제 코드

### 6.1 Clean Architecture 완전 적용 예제

#### Domain Layer

```dart
// features/auth/domain/user.dart - Entity (순수 객체)
class User {
  final String id;
  final String name;
  final String email;
  final String? profileImageUrl;
  final AuthProvider provider;
  final DateTime createdAt;
  
  const User({...});
  
  User copyWith({...}) {
    // ...
  }
}

// features/auth/domain/repositories/auth_repository.dart - Repository 인터페이스
abstract class AuthRepository {
  Future<Result<User?>> snsLogin(AuthProvider provider);
  Future<Result<User?>> getCurrentUser();
  Future<Result<void>> logout();
}

// features/auth/domain/usecases/sign_in_usecase.dart - Use Case
class SignInUseCase {
  final AuthRepository _authRepository;
  
  SignInUseCase(this._authRepository);
  
  Future<Result<User?>> call(AuthProvider provider) {
    return _authRepository.snsLogin(provider);
  }
}
```

#### Data Layer

```dart
// features/auth/data/dtos/user_dto.dart - DTO (JSON 직렬화 포함)
@JsonSerializable()
class UserDto {
  final String id;
  final String name;
  final String email;
  @JsonKey(name: 'profile_image_url')
  final String? profileImageUrl;
  final String provider;
  @JsonKey(name: 'created_at')
  final String createdAt;
  
  factory UserDto.fromJson(Map<String, dynamic> json) => _$UserDtoFromJson(json);
  Map<String, dynamic> toJson() => _$UserDtoToJson(this);
  
  // Entity 변환
  User toEntity() {
    return User(
      id: id,
      name: name,
      email: email,
      profileImageUrl: profileImageUrl,
      provider: _parseProvider(provider),
      createdAt: DateTime.parse(createdAt),
    );
  }
}

// features/auth/data/datasources/supabase_auth_datasource.dart - Datasource
class SupabaseAuthDatasource {
  Future<Result<User?>> snsLogin(AuthProvider provider) async {
    try {
      final response = await SupabaseService.client.auth.signInWithOAuth(...);
      final userDto = UserDto.fromJson(response);
      final user = userDto.toEntity(); // DTO → Entity
      return Success<User?>(user);
    } catch (e) {
      return Failure<User?>('로그인 실패: $e');
    }
  }
}

// features/auth/data/repositories/supabase_auth_repository.dart - Repository 구현체
class SupabaseAuthRepository implements AuthRepository {
  final SupabaseAuthDatasource _authDatasource;
  
  SupabaseAuthRepository(this._authDatasource);
  
  @override
  Future<Result<User?>> snsLogin(AuthProvider provider) {
    return _authDatasource.snsLogin(provider);
  }
}
```

#### Presentation Layer

```dart
// features/auth/presentation/viewmodels/auth_viewmodel.dart - ViewModel
class AuthViewModel extends StateNotifier<Result<User?>> {
  final SignInUseCase _signInUseCase;
  final GetCurrentUserUseCase _getCurrentUserUseCase;
  
  AuthViewModel({
    required SignInUseCase signInUseCase,
    required GetCurrentUserUseCase getCurrentUserUseCase,
  })  : _signInUseCase = signInUseCase,
        _getCurrentUserUseCase = getCurrentUserUseCase,
        super(Success<User?>(null));
  
  Future<void> signIn(AuthProvider provider) async {
    state = Pending<User?>('로그인 중...');
    final result = await _signInUseCase(provider); // Use Case 사용
    state = result;
  }
}

```

---

## 7. 데이터 흐름

### 6.1 로그인 플로우 (Clean Architecture)

```
1. View (AuthScreen)
   └─> 사용자가 "Google 로그인" 버튼 클릭
       └─> viewModel.signIn(AuthProvider.google) 호출

2. ViewModel (AuthViewModel)
   └─> _signInUseCase(provider) 호출
       └─> 상태를 Pending으로 변경

3. Use Case (SignInUseCase)
   └─> _authRepository.snsLogin(provider) 호출

4. Repository 구현체 (SupabaseAuthRepository)
   └─> _authDatasource.snsLogin(provider) 호출

5. Datasource (AuthDatasource)
   └─> SupabaseService.client.auth.signInWithOAuth() 호출
       └─> 응답 데이터를 UserDto로 변환
       └─> UserDto.toEntity()로 User Entity 변환

6. Service (SupabaseService)
   └─> Supabase SDK를 통해 실제 API 호출
       └─> 결과 반환

7. 역순으로 결과 전달
   Service → Datasource (DTO→Entity) → Repository → Use Case → ViewModel → View
   
8. View 업데이트
   └─> authResult.when()으로 UI 상태 변경
```

### 6.2 게시글 목록 조회 플로우 (Clean Architecture)

```
1. View (PostListScreen)
   └─> 화면 진입 시 자동 로드
       └─> ref.watch(postListViewModelProvider) 감시

2. ViewModel (PostListViewModel - autoDispose)
   └─> 화면 진입 시 자동 생성
       └─> _getPostsUseCase() 호출

3. Use Case (GetPostsUseCase)
   └─> _postRepository.getPosts() 호출

4. Repository 구현체 (SupabasePostRepository)
   └─> postDatasource.getPosts() 호출

5. Datasource (PostDatasource)
   └─> JOIN 쿼리 실행:
       .select('*, user_profiles!user_id(name, profile_image_url)')
       └─> PostDto.fromJson()로 DTO 생성
       └─> PostDto.toEntity()로 Post Entity 변환

6. 역순으로 결과 전달
   Datasource (DTO→Entity) → Repository → Use Case → ViewModel → View

7. View 업데이트
   └─> 게시글 목록 표시 (작성자 정보 포함)
```

---

## 7. Provider 구조와 의존성 역전 원칙

### 7.1 Clean Architecture를 위한 Provider 구조

Clean Architecture의 의존성 역전 원칙(Dependency Inversion Principle)을 준수하기 위해, Provider를 레이어별로 분리하여 관리합니다.

#### 레이어별 Provider 분리

```
features/{feature}/
├── data/
│   ├── datasource_providers.dart      # Datasource Provider (Data 레이어)
│   └── repository_providers.dart      # Repository 구현 Provider (Data 레이어)
└── presentation/
    ├── providers/
    │   └── providers.dart             # 통합 export (사용 편의성)
    ├── usecase_providers.dart         # UseCase Provider (Presentation 레이어)
    └── viewmodel_providers.dart       # ViewModel Provider (Presentation 레이어)
```

#### 각 레이어의 역할

**1. Data Layer Providers (`data/datasource_providers.dart`, `data/repository_providers.dart`)**
- Datasource의 구체 구현 관리
- Repository의 구체 구현 관리
- Domain 인터페이스를 반환 (추상화)

**2. Presentation Layer Providers (`presentation/usecase_providers.dart`, `presentation/viewmodel_providers.dart`)**
- UseCase Provider: Domain UseCase만 참조, Repository 인터페이스(도메인)만 의존
- ViewModel Provider: UseCase만 참조

**3. 통합 Export (`presentation/providers/providers.dart`)**
- 모든 Provider를 한 곳에서 export하여 사용 편의성 제공
- 실제 구현은 레이어별로 분리되어 있어 Clean Architecture 원칙 준수

#### 의존성 방향

```
ViewModel Providers (Presentation)
    ↓ UseCase만 참조
UseCase Providers (Presentation)
    ↓ Repository 인터페이스(도메인)만 참조
Repository Providers (Data)
    ↓ Datasource만 참조
Datasource Providers (Data)
    ↓ 구체 구현
Datasource 구현체 (Data)
```

### 7.2 Provider 구조 예제

#### Data Layer

**`data/datasource_providers.dart`**:
```dart
final supabaseAuthDatasourceProvider = Provider<SupabaseAuthDatasource>((ref) {
  return SupabaseAuthDatasource();
});
```

**`data/repository_providers.dart`**:
```dart
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  final authDatasource = AuthDatasource();
  return SupabaseAuthRepository(authDatasource: authDatasource, ...);
});
```

#### Presentation Layer

**`presentation/usecase_providers.dart`**:
```dart
final signInUseCaseProvider = Provider<SignInUseCase>((ref) {
  final repository = ref.watch(authRepositoryProvider); // Domain 인터페이스
  return SignInUseCase(repository);
});
```

**`presentation/viewmodel_providers.dart`**:
```dart
final authViewModelProvider = StateNotifierProvider<AuthViewModel, Result<User?>>((ref) {
  final signInUseCase = ref.watch(signInUseCaseProvider); // UseCase만 참조
  // ...
  return AuthViewModel(signInUseCase: signInUseCase, ...);
});
```

**`presentation/providers/providers.dart`** (통합 export):
```dart
export '../../data/datasource_providers.dart';
export '../../data/repository_providers.dart';
export '../usecase_providers.dart';
export '../viewmodel_providers.dart';
```

### 7.3 의존성 역전 원칙 준수

이 구조를 통해 다음을 달성합니다:

1. **Presentation 레이어는 Domain만 참조**: UseCase, Repository 인터페이스만 사용
2. **Data 레이어는 Domain 인터페이스를 구현**: Repository 구현체가 Domain 인터페이스를 반환
3. **의존성은 항상 안쪽(Domain)으로**: 외부 레이어가 내부 레이어에 의존

#### 사용 예시

```dart
// 다른 파일에서 사용
import 'package:lionsns/features/auth/presentation/providers/providers.dart';

// 하나의 import로 모든 Provider 접근 가능
final viewModel = ref.watch(authViewModelProvider);
final useCase = ref.watch(signInUseCaseProvider);
final repository = ref.watch(authRepositoryProvider);
```

---

## 8. Riverpod 상태 관리

### 8.1 Riverpod이란?

**Riverpod**은 Flutter를 위한 강력한 상태 관리 및 의존성 주입 라이브러리입니다. 이 프로젝트에서 Riverpod은 Clean Architecture의 의존성 주입을 담당하며, 다음과 같은 역할을 합니다:

1. **상태 관리**: ViewModel의 상태를 관리하고 UI에 반영
2. **의존성 주입**: UseCase, Repository, Datasource 등의 의존성을 주입
3. **자동 리빌드**: 상태 변경 시 관련 위젯 자동 업데이트
4. **메모리 관리**: 사용하지 않는 Provider 자동 해제
5. **의존성 역전 원칙 준수**: Domain 레이어가 Data 레이어를 직접 import하지 않도록 지원

### 8.2 주요 개념

#### Provider

Provider는 값을 제공하는 객체입니다. Riverpod의 핵심 개념으로, 의존성 주입과 상태 관리를 담당합니다.

**종류**:
- `Provider<T>`: 단순 값 제공 (UseCase, Repository 등)
- `StateNotifierProvider<T>`: 상태 관리용 (ViewModel)
- `FutureProvider<T>`: 비동기 데이터 제공
- `StreamProvider<T>`: 스트림 데이터 제공

#### StateNotifier

`StateNotifier`는 상태 변경 로직을 캡슐화하는 클래스입니다. ViewModel이 `StateNotifier`를 상속하여 상태를 관리합니다.

**특징**:
- `state` 속성으로 현재 상태 접근
- `state = newState`로 상태 변경
- 상태 변경 시 자동으로 UI 업데이트
- UseCase를 통해 비즈니스 로직 실행

#### ConsumerWidget

`ConsumerWidget`은 Provider를 사용하는 위젯입니다. `WidgetRef`를 통해 Provider에 접근할 수 있습니다.

**주요 메서드**:
- `ref.watch(provider)`: 상태 감시 및 자동 리빌드
- `ref.read(provider)`: 상태 읽기 (일회성, 이벤트 처리)
- `ref.listen(provider, callback)`: 상태 변경 감지 및 콜백 실행

### 8.3 Clean Architecture와의 통합

Riverpod은 Clean Architecture의 의존성 주입을 담당합니다:

```
Presentation Layer (ViewModel Provider)
    ↓ ref.watch()
Domain Layer (UseCase Provider)
    ↓ ref.watch()
Data Layer (Repository Provider)
    ↓ ref.watch()
Core Layer (Service Provider)
```

**의존성 방향**:
- Presentation → Domain (UseCase Provider)
- Domain → Data (Repository Provider, Factory Provider)
- Data → Core (Service Provider)

이를 통해 Clean Architecture의 의존성 역전 원칙(DIP)을 준수합니다.

### 8.4 Provider 스코프 관리

#### 전역 스코프 (앱 전체 생명주기)
```dart
// StateNotifierProvider (전역)
final authViewModelProvider = StateNotifierProvider<AuthViewModel, Result<User?>>((ref) {
  final signInUseCase = ref.watch(signInUseCaseProvider);
  final getCurrentUserUseCase = ref.watch(getCurrentUserUseCaseProvider);
  final logoutUseCase = ref.watch(logoutUseCaseProvider);
  final watchAuthStateUseCase = ref.watch(watchAuthStateUseCaseProvider);
  return AuthViewModel(
    signInUseCase: signInUseCase,
    getCurrentUserUseCase: getCurrentUserUseCase,
    logoutUseCase: logoutUseCase,
    watchAuthStateUseCase: watchAuthStateUseCase,
  );
});
```

**사용 사례**:
- 인증 상태 (앱 전체에서 필요)
- 전역 설정

#### 위젯 스코프 (화면 진입 시 생성, 벗어나면 해제)
```dart
// StateNotifierProvider.autoDispose
final postListViewModelProvider = StateNotifierProvider.autoDispose<PostListViewModel, Result<List<Post>>>((ref) {
  final getPostsUseCase = ref.watch(getPostsUseCaseProvider);
  final deletePostUseCase = ref.watch(deletePostUseCaseProvider);
  final viewModel = PostListViewModel(
    getPostsUseCase: getPostsUseCase,
    deletePostUseCase: deletePostUseCase,
  );
  viewModel.loadPosts(); // 화면 진입 시 새로 로드
  return viewModel;
});
```

**사용 사례**:
- 게시글 목록 (화면을 벗어나면 해제)
- 게시글 상세 (특정 ID의 데이터)
- 폼 데이터 (임시 데이터)

#### Family (파라미터별 인스턴스)
```dart
// StateNotifierProvider.autoDispose.family
final postDetailViewModelProvider = StateNotifierProvider.autoDispose.family<PostDetailViewModel, PostDetailState, String>((ref, postId) {
  final getPostByIdUseCase = ref.watch(getPostByIdUseCaseProvider);
  final getCommentsUseCase = ref.watch(getCommentsUseCaseProvider);
  final createCommentUseCase = ref.watch(createCommentUseCaseProvider);
  final deleteCommentUseCase = ref.watch(deleteCommentUseCaseProvider);
  final toggleLikeUseCase = ref.watch(toggleLikeUseCaseProvider);
  final getLikeCountUseCase = ref.watch(getLikeCountUseCaseProvider);
  final getCurrentUserUseCase = ref.watch(getCurrentUserUseCaseProvider);
  final viewModel = PostDetailViewModel(
    getPostByIdUseCase: getPostByIdUseCase,
    getCommentsUseCase: getCommentsUseCase,
    createCommentUseCase: createCommentUseCase,
    deleteCommentUseCase: deleteCommentUseCase,
    toggleLikeUseCase: toggleLikeUseCase,
    getLikeCountUseCase: getLikeCountUseCase,
    getCurrentUserUseCase: getCurrentUserUseCase,
  );
  viewModel.loadPost(postId);
  return viewModel;
});
```

**사용 사례**:
- 게시글 상세 (postId별 인스턴스)
- 사용자 프로필 (userId별 인스턴스)
- 팔로우 상태 (targetUserId별 인스턴스)

### 8.5 ref.watch vs ref.read

#### ref.watch()

상태를 감시하고, 상태가 변경되면 자동으로 위젯을 리빌드합니다.

**사용 시기**:
- UI에 표시할 데이터를 읽을 때
- 상태 변경 시 자동 업데이트가 필요할 때

**예제**:
```dart
class AuthScreen extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 상태 감시 - 변경 시 자동 리빌드
    final authResult = ref.watch(authViewModelProvider);
    
    return authResult.when(
      success: (user) => _buildProfile(user),
      failure: (message, _) => _buildError(message),
      pending: (_) => _buildLoading(),
    );
  }
}
```

#### ref.read()

상태를 한 번만 읽습니다. 리빌드를 트리거하지 않습니다.

**사용 시기**:
- 이벤트 핸들러에서 메서드 호출 시
- 일회성 작업 수행 시

**예제**:
```dart
ElevatedButton(
  onPressed: () {
    // 일회성 호출 - 리빌드 트리거 안 함
    ref.read(authViewModelProvider.notifier).signIn(AuthProvider.google);
  },
  child: Text('Google 로그인'),
)
```

### 8.6 현재 프로젝트의 Provider 스코프

#### 전역 스코프
- `authViewModelProvider` - 인증 상태 (앱 전체 필요)

#### autoDispose
- `postListViewModelProvider` - 게시글 목록
- `postFormViewModelProvider` - 게시글 작성/수정
- `profileEditViewModelProvider` - 프로필 편집

#### autoDispose.family
- `postDetailViewModelProvider` - 게시글 상세 (postId별)
- `followViewModelProvider` - 팔로우 상태 (userId별)

### 8.7 장점

1. **메모리 효율**: 사용하지 않는 ViewModel 자동 해제
2. **데이터 최신성**: 화면 재진입 시 최신 데이터 로드
3. **코드 단순화**: 수동 invalidate 감소
4. **성능 향상**: 불필요한 상태 유지 방지

---

---

## 10. 네이밍 컨벤션

### 파일명
- `*_datasource.dart`: Data Source
- `*_repository.dart`: Repository (인터페이스 또는 구현)
- `*_viewmodel.dart`: ViewModel
- `*_screen.dart`: Screen (또는 `*_page.dart`)
- `*_widget.dart`: Widget
- `*_providers.dart`: Providers

### 클래스명
- `*DataSource`: Data Source 클래스
- `*Repository`: Repository 인터페이스
- `*RepositoryImpl` 또는 `Supabase*Repository`: Repository 구현체
- `*ViewModel`: ViewModel 클래스
- `*Screen`: Screen 클래스
- `*Widget`: Widget 클래스

### 변수명
- `*Provider`: Riverpod Provider
- `*Result`: Result 타입 변수
- `*State`: 상태 변수

---

## 11. 위젯 아키텍처

### 11.1 위젯 데이터 흐름

```
┌─────────────┐
│   Supabase  │
│  (Database) │
└──────┬──────┘
       │
       ▼
┌─────────────────┐
│ WidgetDataService│ ◄── 사용자 통계 집계
└──────┬──────────┘
       │
       ▼
┌──────────────────┐
│ SharedPreferences│ ◄── 데이터 저장 (Flutter)
└──────┬───────────┘
       │
       ├─────────────────┬─────────────────┐
       ▼                 ▼                 ▼
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│   Android   │  │     iOS     │  │   Flutter   │
│   Widget    │  │   Widget    │  │     App     │
│  (Glance)   │  │ (WidgetKit) │  │             │
└─────────────┘  └─────────────┘  └─────────────┘
```

### 11.2 주요 컴포넌트

#### Flutter 측
- **WidgetDataService** (`lib/core/services/internal/widget_data_service.dart`): 데이터 집계 및 저장
- **WidgetUpdateService** (`lib/core/services/internal/widget_update_service.dart`): Method Channel 통신
- **DeepLinkService** (`lib/core/services/internal/deep_link_service.dart`): Deep Link 처리
- **WidgetDataKeys** (`lib/core/constants/widget_data_keys.dart`): SharedPreferences 키 관리

#### Android 측
- **HomeWidget.kt**: Jetpack Compose Glance 위젯 UI
- **HomeWidgetReceiver.kt**: 위젯 리시버
- **MainActivity.kt**: Method Channel 및 Deep Link 처리

#### iOS 측
- **HomeWidget.swift**: WidgetKit Extension (SwiftUI)
- **AppDelegate.swift**: Method Channel 처리

### 11.3 위젯 업데이트 트리거

위젯은 다음 시점에 자동으로 업데이트됩니다:

1. **앱 시작 시** (`MainNavigationScreen`)
2. **로그인/로그아웃 시** (`AuthViewModel`)
3. **게시글 작성/수정 시** (`PostFormScreen`)

### 11.4 위젯과 Clean Architecture 통합

위젯 관련 서비스들은 Clean Architecture의 Core Layer에 위치합니다:

- **WidgetDataService**: Supabase에서 데이터를 조회하고 SharedPreferences에 저장 (Service Layer)
- **WidgetUpdateService**: 네이티브 플랫폼과 통신 (Service Layer)
- **DeepLinkService**: 위젯에서 앱으로의 네비게이션 처리 (Service Layer)

위젯 자체는 네이티브 코드(Android/iOS)로 구현되며, Flutter와 Method Channel을 통해 통신합니다.

---

## 12. 아키텍처 선택 가이드

### 12.1 Clean Architecture 프로젝트의 특징

 **Clean Architecture가 적합한 경우**:
- 대규모 프로젝트
- 복잡한 비즈니스 로직
- 여러 백엔드 교체 가능성
- 높은 테스트 커버리지 필요
- 장기 유지보수 중요

**이 프로젝트의 Clean Architecture 준수 현황**:
-  모든 ViewModel이 UseCase만 사용
-  Repository/Datasource 직접 사용 완전 제거
-  Factory 패턴으로 완벽한 DIP 준수
-  Presentation 레이어가 Domain 레이어만 import
-  모든 feature에 일관된 구조 적용 (search, auth, feed)
-  Clean Architecture 원칙 위반 사항 없음

### 13.2 MVVM 프로젝트와 비교

**간단한 구조가 필요한 경우** → `LionSNS-MVVM` 프로젝트 참고

| 특징 | Clean Architecture (이 프로젝트) | MVVM |
|------|-------------------------------|------|
| 복잡도 | 높음 | 낮음 |
| 개발 속도 | 느림 | 빠름 |
| 테스트 용이성 | 높음 | 보통 |
| 확장성 | 높음 | 보통 |
| 학습 곡선 | 높음 | 낮음 |

---

## 10. 네이밍 컨벤션

### 파일명
- `*_datasource.dart`: Data Source
- `*_repository.dart`: Repository (인터페이스 또는 구현)
- `*_usecase.dart`: Use Case
- `*_dto.dart`: DTO (Data Transfer Object)
- `*_viewmodel.dart`: ViewModel
- `*_screen.dart`: Screen (또는 `*_page.dart`)
- `*_widget.dart`: Widget
- `*_providers.dart`: Providers

### 클래스명
- `*DataSource`: Data Source 클래스
- `*Repository`: Repository 인터페이스
- `*RepositoryImpl` 또는 `Supabase*Repository`: Repository 구현체
- `*UseCase`: Use Case 클래스
- `*DTO`: DTO 클래스
- `*ViewModel`: ViewModel 클래스
- `*Screen`: Screen 클래스
- `*Widget`: Widget 클래스

### 변수명
- `*Provider`: Riverpod Provider
- `*Result`: Result 타입 변수
- `*State`: 상태 변수

---

## 11. 참고 문서

- [프로젝트 파일 구조](./프로젝트_파일_구조.md) - 실제 파일 구조 상세 설명
- [설정/Supabase_초기_설정_가이드.md](../설정/Supabase_초기_설정_가이드.md) - 백엔드 설정
- [설정/위젯_구현_가이드.md](../설정/위젯_구현_가이드.md) - 위젯 구현 가이드
- [설정/다국어_가이드.md](../설정/다국어_가이드.md) - 다국어 처리 가이드

